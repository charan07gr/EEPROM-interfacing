# EEPROM Interfacing 

##  AIM:
To interface the EEPROM with Arduino UNO controller and read the values from the EEPROM

## Software required:
Arduino IDE </br>
Proteous

## PROCEDURE:
### Arduino IDE
Step1:Open the Arduino IDE </br>
Step2: Go to file and select new file option </br>
Step3:Type the program </br>
Step4:Go to file and select save option to save the program </br>
Step5:Go to sketch and select verify or compile options </br>
Step6:If no error Hex file will be generated in the temporary folder </br>
### Proteus
Step7:Open the Proteus software </br>
Step8:Go to file select new design and click ok button </br>
Step9:Select component mode and click pick devices from the library </br>
Step10:Type the component name in the keyword to select the components and click ok button </br>
Step11:Design the circuit as per the diagram </br>
Step12:Double click the Arduino controller and upload the hex file generated by Arduino IDE </br>
Step13:Click start button and check the output

## THEORY:

In this project, we will show how to connect an 24LC256 EEPROM chip to an arduino micrcontroller.EEPROM stands for Electrically Erasable Programmanble Read-Only Memory.
EEPROM is very important and useful because it is a non-volatile form of memory. This means that even when the board is powered off, the EEPROM chip still retains the program that was written to it. So when you power off the board and then power it back on, the program that was written to the EEPROM can be run. So basically, the EEPROM stores and runs a program no matter what. This means you can turn off a device, keep it off for 3 days, and come back and turn it on and it can still run the program that was programmed in it. This is how most consumer electronic devices work.EEPROM is also very efficient in that individual bytes in a traditional EEPROM can be independently read, erased, and rewritten. In most other kinds of non-volatile memory, this can't be done.
In this circuit, we will show how to connect a 24LC256 to an arduino and how to program the arduino so that it can write to and read from the 24LC256 chip. We can write anything that we want to it (as long as it's within 256 kilobits of memory) and read from it any time we want.The 24LC256, as the last 3 digits imply, gives an additional 256 kilobits of EEPROM to an arduino micrcontroller. The EEPROM available on an arduino uno is 512 bytes of memory. So adding 24LC256 chip for EEPROM expansion is a significant one. It gives great EEPROM expansion.The 24LC256 EEPROM can operate on power anywhere from 2.5-5.5V

![image](https://github.com/anishkumar-Embedded/EEPROM-interfacing/assets/71547910/fadc2ed6-05e9-40f8-b5fc-2bb0d40827c7)

First, to power the chip, we connect VCC, pin 8, to 5V. And we connect GND, pin 4, to power ground.The address input pins, A0, A1, and A2, are for multiple device operation. If you are going to connect more than one 24xx256 EEPROM to a microcontroller, you will need to vary the addresses of each of the pins. So there are 3 address, which means there can be a total of 8 EEPROM devices connected together to a microcontroller (since 23= 8). If you have 8 EEPROMs connected together, each of them must have a unique address. The possible addresses are 000, 001, 010, 011, 100, 101, 110, and 111. The reason why each EEPROM must have a unique address is because there would be no other way for the microcontroller to address a specific one. The address is how you can differentiate between all the EEPROM chips. In this circuit, we simply connecting one EEPROM device to the microcontroller. Even with only being used, an address still must be used. We will ground all the address pins. This produces an address of 000. So this is what we will use for this circuit. But you can really make the address anything based on what address pins you pull HIGH or LOW. If you make A0 HIGH and A1 and A2 LOW, then this is an address of 001. If you make A1 and A2 HIGH and A2 LOW, then this is an address of 011. If you make all 3 address pins HIGH, this is an address of 111. It really doesn't matter when you have a single EEPROM. Just remember that when you connecting multiple devices, each one must be unique.
The WP pin, pin 7, is the Write-Protect pin. This pin can enable or disable the microcontroller writing data to the EEPROM chip depending on whether the pin is pulled HIGH Or LOW. If tied to HIGH or VCC, write operations are inhibited. Read operations, however, are not affected. If tied LOW or to VSS, write operations are enabled.The SCL pin, pin 6, is the serial clock line. The 24LC256 operates off a clock signal. The clock is used to synchronize data transfer to and from the device between the arduino microcontroller and the EEPROM chip.The SDA pin, pin 5, is the serial data pin. This is the pin that transfers data between the micrcontroller and the EEPROM chip. It's bidirectional.We will now explain the hardware connections.First to connect power to the 24LC256 chip, we connect VCC, pin 8, to the 5V of power and connect VSS, pin 4, to ground. This establishes power to the EEPROM chip.

The address pins, A0, A1, and A2, which are pins 1, 2, and 3 are all connected to ground. Since they are all grounded, they are all in LOW states. Therefore, the address pins will have a value of 000.The SDA pin, pin 5, of the EEPROM connects to analog pin 4 on the arduino, which is the SDA terminal of the arduino. This is connected via a 10KÎ© pull-up resistor.The SCL pin, pin 6, of the EEPROM connects to analog pin 5 on the arduino, which is the SCL terminal of the arduino. This establishes a clock line so that the master and slave device can work in synchrony.The last pin, the WP (or Write Protect) pin connects to ground. Since we want to write to a device in this circuit, we just permanently connect it to ground. In this circuit, we're not interested in disabling the write feature. However, there are times where it may be very necessary. For example, if you've permanently already written your program to EEPROM and you don't want any modifications at all, just the ability to read from the EEPROM, you can disconnect the write feature by permanently tying the WP pin to VCC. Or you can connect it to a digital pin of a micrcontroller, so that you can switch between enabling or disabling it.

## PROGRAM:
#include "Wire.h" </br>
#define EEPROM_I2C_ADDRESS 0x50 </br>
void setup() </br>
{ </br>
Wire.begin(); </br>
Serial.begin(9600); </br>
int address = 0; </br>
byte val = 120; </br>
writeAddress(address, val); </br>
byte readVal = readAddress(address); </br>
Serial.print("The returned value is "); </br>
Serial.println(readVal); </br>
} </br>
void loop() </br>
{ </br>
 </br>
} </br>
void writeAddress(int address, byte val) </br>
{ </br>
Wire.beginTransmission(EEPROM_I2C_ADDRESS); </br>
Wire.write((int)(address >> 8)); // MSB </br>
Wire.write((int)(address & 0xFF)); // LSB </br>
Wire.write(val); </br>
Wire.endTransmission(); </br>
delay(5); </br>
} </br>
byte readAddress(int address) </br>
{ </br>
byte rData = 0xFF; </br>
Wire.beginTransmission(EEPROM_I2C_ADDRESS); </br>
Wire.write((int)(address >> 8)); // MSB </br>
Wire.write((int)(address & 0xFF)); // LSB </br>
Wire.endTransmission(); </br>
Wire.requestFrom(EEPROM_I2C_ADDRESS, 1); </br>
rData = Wire.read(); </br>
return rData; </br>
} </br>

## CIRCUIT DIAGRAM:
![image](https://github.com/charan07gr/EEPROM-interfacing/assets/132322854/9701ec8d-0146-450f-988c-e41af38e4346)

## OUTPUT:
![image](https://github.com/charan07gr/EEPROM-interfacing/assets/132322854/eaabdf65-6b04-41f8-9336-915d7389f84d)

## RESULT:

Thus the data is read from the EEPROM memory using Arduino controller.
